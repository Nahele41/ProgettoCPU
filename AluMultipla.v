/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module DIG_Counter_Nbit
#(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out,
    output ovf,
    input C,
    input en,
    input clr
);
    reg [(Bits-1):0] count;

    always @ (posedge C) begin
        if (clr)
          count <= 'h0;
        else if (en)
          count <= count + 1'b1;
    end

    assign out = count;
    assign ovf = en? &count : 1'b0;

    initial begin
        count = 'h0;
    end
endmodule


module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


module splitDati64_32 (
  input [63:0] I,
  output [31:0] A,
  output [31:0] B
);
  assign A = I[31:0];
  assign B = I[63:32];
endmodule

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


// Coder con tre bit di ingresso e due di uscita
module CoderMio (
  input Z0,
  input Z1,
  input Z2,
  output Y0,
  output Y1
);
  assign Y0 = (Z0 & Z1);
  assign Y1 = (Z0 & Z2);
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module AluMia (
  input [31:0] A,
  input X0,
  input [31:0] B,
  input X1,
  input X2,
  output R,
  output [31:0] S
);
  wire [31:0] s0;
  wire [31:0] s1;
  wire [31:0] s2;
  wire [31:0] s3;
  wire [1:0] s4;
  wire [31:0] s5;
  wire [31:0] s6;
  wire s7;
  wire s8;
  assign s3 = ~ B;
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i0 (
    .sel( X0 ),
    .in_0( 32'b0 ),
    .in_1( A ),
    .out( s0 )
  );
  assign s6 = (B & A);
  assign s5 = (B | A);
  CoderMio CoderMio_i1 (
    .Z0( X0 ),
    .Z1( X1 ),
    .Z2( X2 ),
    .Y0( s7 ),
    .Y1( s8 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i2 (
    .sel( X1 ),
    .in_0( B ),
    .in_1( s3 ),
    .out( s1 )
  );
  assign s4[0] = s7;
  assign s4[1] = s8;
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i3 (
    .a( s0 ),
    .b( s1 ),
    .c_i( X2 ),
    .s( s2 ),
    .c_o( R )
  );
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i4 (
    .sel( s4 ),
    .in_0( s2 ),
    .in_1( s5 ),
    .in_2( s6 ),
    .in_3( s2 ),
    .out( S )
  );
endmodule

module DemuxBus2
#(
    parameter Bits = 2,
    parameter Default = 0 
)
(
    output [(Bits-1):0] out_0,
    output [(Bits-1):0] out_1,
    output [(Bits-1):0] out_2,
    output [(Bits-1):0] out_3,
    input [1:0] sel,
    input [(Bits-1):0] in
);
    assign out_0 = (sel == 2'h0)? in : Default;
    assign out_1 = (sel == 2'h1)? in : Default;
    assign out_2 = (sel == 2'h2)? in : Default;
    assign out_3 = (sel == 2'h3)? in : Default;
endmodule


module Demux2
#(
    parameter Default = 0 
)
(
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    input [1:0] sel,
    input in
);
    assign out_0 = (sel == 2'h0)? in : Default;
    assign out_1 = (sel == 2'h1)? in : Default;
    assign out_2 = (sel == 2'h2)? in : Default;
    assign out_3 = (sel == 2'h3)? in : Default;
endmodule


module Decoder2 (
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    input [1:0] sel
);
    assign out_0 = (sel == 2'h0)? 1'b1 : 1'b0;
    assign out_1 = (sel == 2'h1)? 1'b1 : 1'b0;
    assign out_2 = (sel == 2'h2)? 1'b1 : 1'b0;
    assign out_3 = (sel == 2'h3)? 1'b1 : 1'b0;
endmodule

module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule

module DIG_D_FF_Nbit
#(
    parameter Bits = 2,
    parameter Default = 0
)
(
   input [(Bits-1):0] D,
   input C,
   output [(Bits-1):0] Q,
   output [(Bits-1):0] \~Q
);
    reg [(Bits-1):0] state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


// Registro S (32 bit) per la somma, R(1 bit) per il resto
module RegistroSR (
  input [31:0] S,
  input R,
  input C,
  input Sel,
  output Ro,
  output [31:0] So
);
  wire s0;
  wire Ro_temp;
  wire [31:0] s1;
  wire [31:0] So_temp;
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i0 (
    .D( s0 ),
    .C( C ),
    .Q( Ro_temp )
  );
  DIG_D_FF_Nbit #(
    .Bits(32),
    .Default(0)
  )
  DIG_D_FF_Nbit_i1 (
    .D( s1 ),
    .C( C ),
    .Q( So_temp )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i2 (
    .sel( Sel ),
    .in_0( So_temp ),
    .in_1( S ),
    .out( s1 )
  );
  Mux_2x1 Mux_2x1_i3 (
    .sel( Sel ),
    .in_0( Ro_temp ),
    .in_1( R ),
    .out( s0 )
  );
  assign Ro = Ro_temp;
  assign So = So_temp;
endmodule

// Register File with 4 Flip-Flop.
module registerFile (
  input clock,
  input [1:0] RD, // Register Destination
  input [1:0] RV, // Register Value
  input Rin, // Resto entrante
  input [31:0] Sin, // Somma entrante
  output R,
  output [31:0] S
);
  wire [31:0] s0;
  wire [31:0] s1;
  wire [31:0] s2;
  wire [31:0] s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  wire [31:0] s10;
  wire s11;
  wire s12;
  wire [31:0] s13;
  wire s14;
  wire s15;
  wire [31:0] s16;
  wire s17;
  wire s18;
  wire [31:0] s19;
  wire [32:0] s20;
  wire [32:0] s21;
  wire [32:0] s22;
  wire [32:0] s23;
  wire [32:0] s24;
  DemuxBus2 #(
    .Bits(32),
    .Default(0)
  )
  DemuxBus2_i0 (
    .sel( RD ),
    .in( Sin ),
    .out_0( s0 ),
    .out_1( s1 ),
    .out_2( s2 ),
    .out_3( s3 )
  );
  Demux2 #(
    .Default(0)
  )
  Demux2_i1 (
    .sel( RD ),
    .in( Rin ),
    .out_0( s4 ),
    .out_1( s5 ),
    .out_2( s6 ),
    .out_3( s7 )
  );
  Decoder2 Decoder2_i2 (
    .sel( RD ),
    .out_0( s8 ),
    .out_1( s11 ),
    .out_2( s14 ),
    .out_3( s17 )
  );
  RegistroSR RegistroSR_i3 (
    .S( s0 ),
    .R( s4 ),
    .C( clock ),
    .Sel( s8 ),
    .Ro( s9 ),
    .So( s10 )
  );
  RegistroSR RegistroSR_i4 (
    .S( s1 ),
    .R( s5 ),
    .C( clock ),
    .Sel( s11 ),
    .Ro( s12 ),
    .So( s13 )
  );
  RegistroSR RegistroSR_i5 (
    .S( s2 ),
    .R( s6 ),
    .C( clock ),
    .Sel( s14 ),
    .Ro( s15 ),
    .So( s16 )
  );
  RegistroSR RegistroSR_i6 (
    .S( s3 ),
    .R( s7 ),
    .C( clock ),
    .Sel( s17 ),
    .Ro( s18 ),
    .So( s19 )
  );
  assign s21[0] = s12;
  assign s21[32:1] = s13;
  assign s22[0] = s15;
  assign s22[32:1] = s16;
  assign s23[0] = s18;
  assign s23[32:1] = s19;
  assign s20[0] = s9;
  assign s20[32:1] = s10;
  Mux_4x1_NBits #(
    .Bits(33)
  )
  Mux_4x1_NBits_i7 (
    .sel( RV ),
    .in_0( s20 ),
    .in_1( s21 ),
    .in_2( s22 ),
    .in_3( s23 ),
    .out( s24 )
  );
  assign R = s24[0];
  assign S = s24[32:1];
endmodule

module AluMultipla (
  input [31:0] A,
  input [31:0] B,
  input [31:0] A1,
  input [31:0] B1,
  input [31:0] A2,
  input [31:0] B2,
  input [31:0] A3,
  input [31:0] B3,
  input X0,
  input X1,
  input X2,
  input Clock,
  output R,
  output [31:0] S
);
  wire [31:0] s0;
  wire [31:0] s1;
  wire s2;
  wire [31:0] s3;
  wire [1:0] s4;
  wire [63:0] s5;
  wire [63:0] s6;
  wire [63:0] s7;
  wire [63:0] s8;
  wire [63:0] s9;
  assign s5[31:0] = A;
  assign s5[63:32] = B;
  assign s6[31:0] = A1;
  assign s6[63:32] = B1;
  assign s7[31:0] = A2;
  assign s7[63:32] = B2;
  assign s8[31:0] = A3;
  assign s8[63:32] = B3;
  // PC
  DIG_Counter_Nbit #(
    .Bits(2)
  )
  DIG_Counter_Nbit_i0 (
    .en( 1'b1 ),
    .C( Clock ),
    .clr( 1'b0 ),
    .out( s4 )
  );
  Mux_4x1_NBits #(
    .Bits(64)
  )
  Mux_4x1_NBits_i1 (
    .sel( s4 ),
    .in_0( s5 ),
    .in_1( s6 ),
    .in_2( s7 ),
    .in_3( s8 ),
    .out( s9 )
  );
  splitDati64_32 splitDati64_32_i2 (
    .I( s9 ),
    .A( s0 ),
    .B( s1 )
  );
  // ALU
  AluMia AluMia_i3 (
    .A( s0 ),
    .X0( X0 ),
    .B( s1 ),
    .X1( X1 ),
    .X2( X2 ),
    .R( s2 ),
    .S( s3 )
  );
  registerFile registerFile_i4 (
    .clock( Clock ),
    .RD( s4 ),
    .RV( s4 ),
    .Rin( s2 ),
    .Sin( s3 ),
    .R( R ),
    .S( S )
  );
endmodule
